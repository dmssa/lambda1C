Реализация идеи попробовать программирование на 1с в стиле функционального программирования в LINQ.
Берём общий модуль, пишем в нём функции, возращающие объект модуля. В результате мы можем обращаться к функциям "змейкой": 

Объект1 = Наборы.Действие1(Прм1, Прм2)
			    .Действие2()
			    .Результат();

Но хранить в модуле значения переменных нельзя. Для этих целей можно воспользоваться разными методами, я использовал структуру, которую буду передавать в каждую функцию. Для её инициализации сделал функцию, которая так же принимает контекст выполнения:

Н = Наборы.НовыйНабор(ЭтаФорма);

Теперь можно передавать в структуре данные, изменять их и форматировать результат:

Н = Наборы.НовыйНабор(ЭтаФорма);
Р = Наборы.ЗадатьДанные(Н, СтрРазделить("21 43 53 39", " "))
          .Выбрать(Н, "Число", Новый Структура("Элемент"))
		  .Отбор(Н, "Элемент>40;")
		  .ВСтроку(Н);
//  Р = "43,53"

Разберём функцию Выбрать. Она изменяет данные элемента коллекции. Первым параметром в функцию передаётся структура с данными(Набор). Второй параметр "ИмяФункции", передаёт либо название функции, доступной в контексте выполнения (ЭтаФорма и глобальный контекст) или код.
Для определения того, что в параметре ИмяФункции передаётся именно код в значении ищется символ ";", иначе считаем, что передали функцию. Третий параметр - структура с количеством аргументов вызываемой функции или просто определение этих переменных, если это код. В этой структуре можно передать локальные переменные процедуры, из которой выполняется вызов Выбрать. 
В данном примере мы применяем к каждому элементу набора функцию Число и передаём ей в качестве параметра внутреннюю переменную Элемент. 
По умолчанию в функцию передаются параметры Элемент, Индекс, Массив, Результат, Набор(структура с данными Н). Их можно использовать в коде, если передаётся код, а так же переменную Результаты. Результатом выполнения кода является первое выражение, если далее Результат не переопределяется.
Применение функций к данным реализовано в последней функции ВСтроку. До этого действия накапливаются в Наборе. Т.е. по элементам массива мы проходим один раз. Накапливаемые функции: Первые, Выбрать, Отбор. Функции перечисляющие коллекцию: Сортировать, ДляКаждого, ВМассив, ВСтроку, Количество, Развернуть.

Аналогичный код в обычном синтаксисе 1С:

Результат = Новый Массив;
Массив = СтрРазделить("21 43 53 39", " ");
Для каждого Элемент Из Массив Цикл
	Значение = Число(Элемент)
	Если Значение > 40 Тогда
		Результат.Добавить(Значение);
	КонецЕсли;
КонецЦикла;
Р = СтрСоединить(Результат, ",");


Плюсы
	+ Наглядность(для знакомых с таким подходом)
	+ Возможность параллельного выполнения
Минусы
	- Низкая производительность из-за команды Выполнить
	- Не удобно производить отладку из-за передачи кода строкой
	